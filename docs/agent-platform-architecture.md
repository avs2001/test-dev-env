# Agent Platform Architecture: IDs, Tasks, and Event Flow

**Document Version:** 1.0
**Created:** 2025-12-26
**Session:** 12

This document provides a comprehensive analysis of the core identification and execution concepts in the agent-sdk2 multi-agent platform.

---

## Table of Contents

1. [Executive Summary](#executive-summary)
2. [Part I: ConversationId and MessageId](#part-i-conversationid-and-messageid)
3. [Part II: Task Concept](#part-ii-task-concept)
4. [Part III: How They Work Together](#part-iii-how-they-work-together)
5. [Part IV: Client Integration Guide](#part-iv-client-integration-guide)

---

## Executive Summary

The agent-sdk2 platform uses three core identifier systems:

| Identifier | Scope | Purpose | Generated By |
|------------|-------|---------|--------------|
| **conversationId** | User session | Groups messages into threads | Client or Server |
| **messageId** | Single message | Tracks individual messages | Server only |
| **taskId** | Agent execution | Tracks agent work units | Server only |

**Relationship:**
```
Conversation (conversationId)
    └── Message (messageId)
            └── Task (taskId)
                    └── Events (via hooks)
```

---

## Part I: ConversationId and MessageId

### 1. ConversationId

#### 1.1 Definition

```typescript
// libs/shared/src/lib/interfaces/conversation.interface.ts:30-36
export interface Conversation {
  id: string;           // <-- This is the conversationId
  title: string;
  createdAt: Date;
  updatedAt: Date;
  metadata?: Record<string, unknown>;
}
```

#### 1.2 Generation

ConversationId is generated in **two scenarios**:

**Scenario A: Client-provided (existing conversation)**
```typescript
// apps/api/src/chat/chat.service.ts:56-64
if (conversationId) {
  try {
    conversation = await this.storage.getConversation(conversationId);
  } catch {
    // If not found, create with the provided ID
    conversation = await this.storage.createConversation({
      id: conversationId,  // Uses client-provided ID
      title: content.substring(0, 50),
    });
  }
}
```

**Scenario B: Server-generated (new conversation)**
```typescript
// apps/api/src/chat/chat.service.ts:65-69
} else {
  conversation = await this.storage.createConversation({
    title: content.substring(0, 50),
  });
  conversationId = conversation.id;  // ID generated by storage
}

// libs/agent-core/src/lib/storage/memory-storage.service.ts:24
id: data.id || uuidv4(),  // UUID v4 if not provided
```

#### 1.3 Purpose and Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        ConversationId Flow                                   │
└─────────────────────────────────────────────────────────────────────────────┘

1. CLIENT REQUEST
   POST /chat/messages
   {
     "content": "Hello",
     "conversationId": "optional-uuid",  // Optional
     "workingDirectory": "/path"
   }
                    │
                    ▼
2. CHAT CONTROLLER (chat.controller.ts:63-83)
   - Validates workingDirectory
   - Passes conversationId to ChatService
   - Returns { conversationId, messageId }
                    │
                    ▼
3. CHAT SERVICE (chat.service.ts:49-91)
   - Creates/retrieves Conversation
   - Creates user Message
   - Passes conversationId to Supervisor via options
                    │
                    ▼
4. SUPERVISOR (supervisor-agent.service.ts:77-87)
   - Stores conversationId in task.context
   const task: AgentTask = {
     context: {
       conversationId: options.conversationId,
     }
   };
                    │
                    ▼
5. EVENT BUS (event-bus.service.ts:46-66)
   - Injects conversationId into all event payloads
   createHooks(taskId, agentId, { conversationId })

   emit: (type, payload) => {
     payload: { ...payload, ...context }  // conversationId merged here
   }
                    │
                    ▼
6. SSE STREAM (chat.service.ts:251-432)
   - Extracts conversationId from event payload
   const conversationId = payload?.['conversationId'];

   - Emits ChatEvent with conversationId
   this.chatEvents.next({
     type: 'task_started',
     conversationId,  // <-- Used for filtering
     ...
   });
                    │
                    ▼
7. CLIENT SSE SUBSCRIPTION
   GET /chat/stream?conversationId=xxx
   - Filters events by conversationId
   - Receives only events for that conversation
```

#### 1.4 Use Cases

| Use Case | Where | How |
|----------|-------|-----|
| **Message grouping** | `MemoryStorageService` | Messages stored in `Map<conversationId, Message[]>` |
| **Context building** | `ChatService.buildPromptWithContext` | Retrieves recent messages for conversation |
| **SSE filtering** | `ChatController.streamEvents` | Clients subscribe to specific conversation events |
| **Event correlation** | `EventBusService.createHooks` | All agent events tagged with conversationId |
| **Session continuity** | API clients | Clients maintain conversationId across requests |

---

### 2. MessageId

#### 2.1 Definition

```typescript
// libs/shared/src/lib/interfaces/conversation.interface.ts:9-25
export interface Message {
  id: string;                    // <-- This is the messageId
  conversationId: string;        // Parent conversation
  role: 'user' | 'assistant' | 'system';
  content: string;
  createdAt: Date;
  metadata?: {
    taskId?: string;             // Links to execution task
    agentId?: string;
    usage?: { inputTokens: number; outputTokens: number };
    duration?: number;
    [key: string]: unknown;
  };
}
```

#### 2.2 Generation

MessageId is **always server-generated** using UUID v4:

```typescript
// apps/api/src/chat/chat.service.ts:73-80
const userMessage: Message = {
  id: uuidv4(),          // <-- Generated here for user messages
  conversationId,
  role: 'user',
  content,
  createdAt: new Date(),
};

// apps/api/src/chat/chat.service.ts:173-188
const assistantMessage: Message = {
  id: uuidv4(),          // <-- Generated here for assistant messages
  conversationId,
  role: 'assistant',
  content: finalContent,
  ...
};
```

#### 2.3 Purpose and Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          MessageId Flow                                      │
└─────────────────────────────────────────────────────────────────────────────┘

1. USER MESSAGE CREATION (chat.service.ts:73-80)
   const userMessage = { id: uuidv4(), ... };
   messageId returned immediately to client
                    │
                    ▼
2. SSE "STARTED" EVENT (chat.service.ts:104-109)
   this.chatEvents.next({
     type: 'started',
     conversationId,
     messageId,           // <-- User's message ID
     timestamp: new Date(),
   });
                    │
                    ▼
3. PROCESSING (async - supervisor executes)
                    │
                    ▼
4. ASSISTANT MESSAGE CREATION (chat.service.ts:173-188)
   const assistantMessage = { id: uuidv4(), ... };  // NEW ID
                    │
                    ▼
5. SSE "COMPLETED" EVENT (chat.service.ts:202-209)
   this.chatEvents.next({
     type: 'completed',
     conversationId,
     messageId: assistantMessage.id,  // <-- Assistant's message ID
     content: finalContent,
     ...
   });
```

#### 2.4 Use Cases

| Use Case | Where | How |
|----------|-------|-----|
| **Message storage** | `MemoryStorageService.addMessage` | Messages indexed by ID in array |
| **Message deletion** | `MemoryStorageService.deleteMessage` | Find by ID and remove |
| **Event correlation** | `ChatEvent.messageId` | Links SSE events to specific message |
| **Response tracking** | API response | Client knows which message triggered processing |

---

### 3. ID Relationship Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         ID Hierarchy                                         │
└─────────────────────────────────────────────────────────────────────────────┘

CONVERSATION (id: conversationId)
│
├── MESSAGE (id: messageId, conversationId: FK)
│   ├── role: 'user'
│   ├── content: "What is 2+2?"
│   └── metadata: { taskId: "task-uuid" }
│
├── MESSAGE (id: messageId, conversationId: FK)
│   ├── role: 'assistant'
│   ├── content: "The answer is 4"
│   └── metadata: { taskId: "task-uuid", agentId: "agent-code", usage: {...} }
│
└── ... more messages


EVENTS (during processing)
│
├── AgentEvent (taskId, conversationId in payload)
│   └── Emitted by: EventBusService
│
└── ChatEvent (conversationId, messageId, taskId)
    └── Emitted by: ChatService (transformed from AgentEvent)


ID RELATIONSHIPS:
┌─────────────┐     1:N      ┌─────────────┐
│Conversation │──────────────│   Message   │
│     id      │              │     id      │
│             │              │conversationId│
└─────────────┘              └─────────────┘
       │                            │
       │                            │
       ▼                            ▼
┌─────────────────────────────────────────┐
│              ChatEvent                   │
│  conversationId: links to conversation   │
│  messageId: links to triggering message  │
│  taskId: links to execution task         │
└─────────────────────────────────────────┘
```

---

## Part II: Task Concept

### 4. What is a Task?

A **Task** is the fundamental unit of work in the agent platform. When a user sends a message, it becomes a task that agents execute.

#### 4.1 Task Definition

```typescript
// libs/shared/src/lib/interfaces/task.interface.ts:45-69
export interface AgentTask {
  /** Unique task identifier */
  id: string;                    // <-- This is the taskId

  /** Task type hint for routing */
  type: TaskType;

  /** The actual prompt/instruction */
  prompt: string;

  /** Optional context */
  context?: TaskContext;

  /** Priority level */
  priority?: TaskPriority;

  /** Timeout in milliseconds (default: 300000 = 5 min) */
  timeout?: number;

  /** Parent task ID (for subtasks) */
  parentTaskId?: string;

  /** Created timestamp */
  createdAt?: Date;
}
```

#### 4.2 Task Context

```typescript
// libs/shared/src/lib/interfaces/task.interface.ts:22-40
export interface TaskContext {
  /** Working directory for file operations */
  workingDirectory?: string;

  /** Results from previous agents (for sequential execution) */
  previousResults?: AgentResult[];

  /** Conversation history for context */
  conversationHistory?: ConversationMessage[];

  /** Conversation ID for tracking */
  conversationId?: string;

  /** Session ID for SDK */
  sessionId?: string;

  /** Any additional metadata */
  metadata?: Record<string, unknown>;
}
```

#### 4.3 Task Types

```typescript
// libs/shared/src/lib/interfaces/common.types.ts:26-52
export type TaskType =
  // General
  | 'general'
  // Code tasks
  | 'code_review'
  | 'code_generate'
  | 'code_refactor'
  | 'code_debug'
  // Research tasks
  | 'research'
  | 'research_web'
  | 'research_docs'
  // Data tasks
  | 'data_analysis'
  | 'data_transform'
  | 'data_visualize'
  // Writing tasks
  | 'content_write'
  | 'documentation'
  // Angular tasks
  | 'angular_project'
  | 'angular_component'
  | 'angular_feature'
  | 'angular_service'
  | 'angular_routing'
  | 'angular_testing'
  | 'angular_optimization';
```

#### 4.4 Task Priority

```typescript
// libs/shared/src/lib/interfaces/common.types.ts:21
export type TaskPriority = 'low' | 'normal' | 'high' | 'critical';
```

---

### 5. Task Lifecycle

#### 5.1 Complete Task Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          TASK LIFECYCLE                                      │
└─────────────────────────────────────────────────────────────────────────────┘

                         ┌──────────────────┐
                         │  User Message    │
                         │  POST /chat/msg  │
                         └────────┬─────────┘
                                  │
                                  ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ PHASE 1: TASK CREATION                                                       │
│                                                                              │
│   ChatService.sendMessage()                                                  │
│       │                                                                      │
│       ├── Creates user Message (messageId)                                   │
│       ├── Calls supervisor.executeTask(prompt, type, options)                │
│       │                                                                      │
│   SupervisorAgentService.executeTask()                                       │
│       │                                                                      │
│       ├── taskId = uuidv4()                                                  │
│       ├── Creates AgentTask object:                                          │
│       │     {                                                                │
│       │       id: taskId,                                                    │
│       │       type: 'general',                                               │
│       │       prompt: "user's message",                                      │
│       │       context: { workingDirectory, conversationId },                 │
│       │       timeout: 300000,                                               │
│       │       createdAt: new Date()                                          │
│       │     }                                                                │
│       │                                                                      │
│       └── Emits 'task:started' event                                         │
└─────────────────────────────────────────────────────────────────────────────┘
                                  │
                                  ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ PHASE 2: ROUTING DECISION                                                    │
│                                                                              │
│   SupervisorAgentService.analyzeAndRoute(task)                               │
│       │                                                                      │
│       ├── Builds agent descriptions for LLM                                  │
│       ├── Queries LLM: "Which agent(s) should handle this?"                  │
│       ├── Parses RoutingDecision:                                            │
│       │     {                                                                │
│       │       strategy: 'single' | 'parallel' | 'sequential',                │
│       │       agents: [{ agentId, agentName, taskDescription, priority }],   │
│       │       reasoning: "Why this routing",                                 │
│       │       confidence: 0.95                                               │
│       │     }                                                                │
│       │                                                                      │
│       └── Emits 'task:progress' with routing decision                        │
└─────────────────────────────────────────────────────────────────────────────┘
                                  │
                                  ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ PHASE 3: AGENT EXECUTION                                                     │
│                                                                              │
│   Based on strategy:                                                         │
│                                                                              │
│   SINGLE/DELEGATE:                                                           │
│       WorkerAgent.execute(task, hooks)                                       │
│                                                                              │
│   PARALLEL:                                                                  │
│       Promise.all([                                                          │
│         agent1.execute(task, hooks),                                         │
│         agent2.execute(task, hooks),                                         │
│       ])                                                                     │
│                                                                              │
│   SEQUENTIAL:                                                                │
│       result1 = await agent1.execute(task, hooks)                            │
│       task.context.previousResults = [result1]                               │
│       result2 = await agent2.execute(task, hooks)                            │
│                                                                              │
│   During execution, agents emit events via hooks:                            │
│       hooks.emit('task:tool_call', { tool, input })                          │
│       hooks.emit('task:tool_result', { tool, output, success })              │
│       hooks.emit('task:output', { content, partial })                        │
│       hooks.emit('task:progress', { message, percentage })                   │
└─────────────────────────────────────────────────────────────────────────────┘
                                  │
                                  ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ PHASE 4: RESULT                                                              │
│                                                                              │
│   AgentResult returned:                                                      │
│       {                                                                      │
│         taskId: "the-task-id",                                               │
│         agentId: "agent-code",                                               │
│         status: 'success' | 'failure' | 'cancelled' | 'timeout',             │
│         output: "The agent's response",                                      │
│         artifacts?: [...],                                                   │
│         usage: { inputTokens, outputTokens },                                │
│         costUsd: 0.05,                                                       │
│         duration: 2500                                                       │
│       }                                                                      │
│                                                                              │
│   Supervisor emits 'task:completed' or 'task:failed'                         │
│   EventBus.cleanupTask(taskId)                                               │
└─────────────────────────────────────────────────────────────────────────────┘
                                  │
                                  ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ PHASE 5: MESSAGE STORAGE                                                     │
│                                                                              │
│   ChatService.processMessage()                                               │
│       │                                                                      │
│       ├── Validates output completeness                                      │
│       ├── Creates assistant Message with taskId in metadata                  │
│       ├── Stores message                                                     │
│       └── Emits 'completed' ChatEvent                                        │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 5.2 Task Generation

```typescript
// libs/internal-agents/src/lib/supervisor/supervisor-agent.service.ts:66-87
async executeTask(
  prompt: string,
  type: TaskType = 'general',
  options: SupervisorOptions = {}
): Promise<{ taskId: string; result: AgentResult | AgentResult[] }> {
  const taskId = uuidv4();  // <-- Task ID generated here
  const startTime = Date.now();

  // Create task object
  const task: AgentTask = {
    id: taskId,
    type,
    prompt,
    context: {
      workingDirectory: options.workingDirectory,
      conversationId: options.conversationId,
    },
    timeout: options.timeout || 300000,
    createdAt: new Date(),
  };

  // ... execution logic
}
```

---

### 6. Task Events

#### 6.1 Event Types

```typescript
// libs/shared/src/lib/interfaces/hooks.interface.ts:11-21
export type AgentEventType =
  | 'task:started'         // Task execution begins
  | 'task:progress'        // Progress update
  | 'task:output'          // Partial or streaming output
  | 'task:tool_call'       // Agent calling a tool
  | 'task:tool_result'     // Tool execution result
  | 'task:subagent_start'  // Subagent spawned
  | 'task:subagent_stop'   // Subagent finished
  | 'task:completed'       // Task finished successfully
  | 'task:failed'          // Task failed
  | 'task:cancelled';      // Task was cancelled
```

#### 6.2 Event Payloads

```typescript
// Task Started
interface TaskStartedPayload {
  prompt: string;
  tools: string[];
  agentId?: string;
  agentName?: string;
}

// Task Progress
interface TaskProgressPayload {
  message: string;
  percentage?: number;
  stage?: string;
  metadata?: Record<string, unknown>;
}

// Task Output (streaming)
interface TaskOutputPayload {
  content: string;
  partial: boolean;
}

// Tool Call
interface TaskToolCallPayload {
  tool: string;
  input: Record<string, unknown>;
  toolUseId?: string;
}

// Tool Result
interface TaskToolResultPayload {
  tool: string;
  output: unknown;
  success: boolean;
  toolUseId?: string;
}

// Task Completed
interface TaskCompletedPayload {
  result: string;
  artifacts?: Artifact[];
  usage?: TokenUsage;
  duration: number;
  costUsd?: number;
}

// Task Failed
interface TaskFailedPayload {
  error: string;
  recoverable: boolean;
  code?: string;
}
```

#### 6.3 How Events Flow

```typescript
// 1. EventBus creates hooks with context (including conversationId)
// libs/agent-core/src/lib/event-bus/event-bus.service.ts:46-71
createHooks(taskId: string, agentId: string, context?: Record<string, unknown>): AgentHooks {
  return {
    emit: (type: AgentEventType, payload: AgentEventPayload) => {
      this.emit({
        id: uuidv4(),
        taskId,
        agentId,
        type,
        timestamp: new Date(),
        payload: context ? { ...payload, ...context } : payload,  // conversationId injected
      });
    },
    isCancelled: () => this.cancelledTasks.has(taskId),
    abortSignal: abortController.signal,
  };
}

// 2. Agents use hooks to emit events
// libs/agent-core/src/lib/worker/base-worker-agent.service.ts:75-81
hooks?.emit('task:started', {
  prompt: task.prompt,
  tools: this.allowedTools,
  agentId: this.metadata.id,
  agentName: this.metadata.name,
});

// 3. ChatService transforms AgentEvents to ChatEvents for SSE
// apps/api/src/chat/chat.service.ts:251-432
private transformAndEmitChatEvent(event: AgentEvent): void {
  const payload = event.payload;
  const conversationId = payload?.['conversationId'];

  switch (event.type) {
    case 'task:started':
      this.chatEvents.next({
        type: 'task_started',
        conversationId,
        taskId: event.taskId,
        agentId: event.agentId,
        // ... more fields
      });
      break;
    // ... other event types
  }
}
```

---

### 7. Task Cancellation

#### 7.1 How to Cancel

```bash
DELETE /chat/tasks/:taskId
```

#### 7.2 Cancellation Flow

```typescript
// 1. Controller receives cancellation request
// apps/api/src/chat/chat.controller.ts:154-158
@Delete('tasks/:taskId')
cancelTask(@Param('taskId') taskId: string) {
  this.chatService.cancelTask(taskId);
  return { success: true, message: 'Task cancellation requested' };
}

// 2. ChatService forwards to Supervisor
// apps/api/src/chat/chat.service.ts:474-476
cancelTask(taskId: string): void {
  this.supervisor.cancelTask(taskId);
}

// 3. Supervisor forwards to EventBus
// libs/internal-agents/src/lib/supervisor/supervisor-agent.service.ts:596-598
cancelTask(taskId: string): void {
  this.eventBus.cancelTask(taskId);
}

// 4. EventBus handles cancellation
// libs/agent-core/src/lib/event-bus/event-bus.service.ts:90-109
cancelTask(taskId: string): void {
  this.cancelledTasks.add(taskId);

  // Abort any pending operations
  const controller = this.abortControllers.get(taskId);
  if (controller) {
    controller.abort();
  }

  // Emit cancelled event
  this.emit({
    id: uuidv4(),
    taskId,
    agentId: 'system',
    type: 'task:cancelled',
    timestamp: new Date(),
    payload: {},
  });
}

// 5. Agents check for cancellation via hooks
// libs/agent-core/src/lib/worker/base-worker-agent.service.ts:84-87
if (hooks?.isCancelled()) {
  throw new Error('Task was cancelled before execution');
}
```

---

### 8. Task Result

#### 8.1 Result Interface

```typescript
// libs/shared/src/lib/interfaces/result.interface.ts:54-90
export interface AgentResult {
  /** Task ID this result is for */
  taskId: string;

  /** Agent that produced this result */
  agentId: string;

  /** Execution status */
  status: ResultStatus;  // 'success' | 'failure' | 'cancelled' | 'timeout'

  /** Main output text */
  output: string;

  /** Error message if failed */
  error?: string;

  /** Artifacts created */
  artifacts?: Artifact[];

  /** Token usage */
  usage?: TokenUsage;

  /** Per-model usage */
  modelUsage?: Record<string, ModelUsage>;

  /** Total cost in USD */
  costUsd?: number;

  /** Execution duration in ms */
  duration: number;

  /** Number of turns/iterations */
  numTurns?: number;

  /** Metadata */
  metadata?: Record<string, unknown>;
}
```

#### 8.2 Token Usage

```typescript
// libs/shared/src/lib/interfaces/result.interface.ts:11-16
export interface TokenUsage {
  inputTokens: number;
  outputTokens: number;
  cacheCreationInputTokens?: number;
  cacheReadInputTokens?: number;
}
```

---

### 9. Execution Strategies

The Supervisor can route tasks to agents using different strategies:

```typescript
// libs/shared/src/lib/interfaces/common.types.ts:62
export type ExecutionStrategy = 'single' | 'parallel' | 'sequential' | 'delegate';
```

#### 9.1 Single

One agent handles the entire task.

```
User Request → Supervisor → Agent-Code → Result
```

#### 9.2 Parallel

Multiple agents work simultaneously on different aspects.

```
                    ┌→ Agent-Code ──────┐
User Request → Supervisor                 ├→ Combined Result
                    └→ Agent-Research ──┘
```

#### 9.3 Sequential

Agents work in order, each building on previous results.

```
User Request → Supervisor → Agent-Research → Agent-Code → Agent-Writer → Result
                              (result 1)      (uses 1)     (uses 1,2)
```

#### 9.4 Delegate

Similar to single, but explicitly delegates to a specialized agent.

---

## Part III: How They Work Together

### 10. Complete Data Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    COMPLETE PLATFORM FLOW                                    │
└─────────────────────────────────────────────────────────────────────────────┘

CLIENT                          SERVER
──────                          ──────

1. Send Message
   POST /chat/messages
   {
     content: "Write a function",
     conversationId: null,          ────────►   ChatService.sendMessage()
     workingDirectory: "/project"                    │
   }                                                 │
                                                     ▼
                                        ┌────────────────────────┐
                                        │ Create/Get Conversation │
                                        │ conversationId = uuid() │
                                        └───────────┬────────────┘
                                                    │
                                                    ▼
                                        ┌────────────────────────┐
                                        │ Create User Message     │
                                        │ messageId = uuid()      │
                                        └───────────┬────────────┘
                                                    │
2. Receive Response                                 │
   {                                                │
     conversationId: "abc-123",     ◄───────────────┤
     messageId: "msg-456"                           │
   }                                                │
                                                    │
                                                    ▼
3. Subscribe to SSE                     ┌────────────────────────┐
   EventSource('/chat/stream            │ Supervisor.executeTask  │
     ?conversationId=abc-123')          │ taskId = uuid()        │
                                        └───────────┬────────────┘
                                                    │
                                                    ▼
                                        ┌────────────────────────┐
                                        │ Create AgentTask        │
                                        │ {                       │
                                        │   id: taskId,           │
                                        │   context: {            │
                                        │     conversationId,     │
                                        │     workingDirectory    │
                                        │   }                     │
                                        │ }                       │
                                        └───────────┬────────────┘
                                                    │
                                                    ▼
                                        ┌────────────────────────┐
                                        │ EventBus.createHooks()  │
                                        │ Injects conversationId  │
                                        │ into all event payloads │
                                        └───────────┬────────────┘
                                                    │
                                                    ▼
                                        ┌────────────────────────┐
                                        │ Agent Execution         │
                                        │ Emits events via hooks: │
                                        │  - task:started         │
                                        │  - task:tool_call       │
4. Receive SSE Events                   │  - task:tool_result     │
   event: task_started          ◄───────│  - task:output          │
   data: {..., taskId, agentId}         │  - task:progress        │
                                        │  - task:completed       │
   event: tool_call             ◄───────└───────────┬────────────┘
   data: {tool: "bash", ...}                        │
                                                    │
   event: task_output           ◄───────────────────┤
   data: {content: "...", ...}                      │
                                                    │
   event: completed             ◄───────────────────┘
   data: {
     conversationId: "abc-123",
     messageId: "msg-789",      // Assistant's message
     content: "Here's your function..."
   }

5. Continue Conversation
   POST /chat/messages
   {
     content: "Add tests",
     conversationId: "abc-123",  // Same conversation
     workingDirectory: "/project"
   }
```

### 11. ID Correlation Table

| ID | Generated When | Generated By | Scope | Persisted |
|----|----------------|--------------|-------|-----------|
| **conversationId** | First message or client-provided | Server or Client | All messages in thread | Yes (storage) |
| **messageId** | Each user/assistant message | Server only | Single message | Yes (storage) |
| **taskId** | Each executeTask() call | Server only | Single execution | No (ephemeral) |
| **eventId** | Each event emission | Server only | Single event | No (ephemeral) |

---

## Part IV: Client Integration Guide

### 12. Quick Start

#### 12.1 Starting a New Conversation

```bash
# Request
POST /chat/messages
Content-Type: application/json

{
  "content": "Hello, I need help with code",
  "workingDirectory": "/path/to/project"
}

# Response
{
  "success": true,
  "conversationId": "550e8400-e29b-41d4-a716-446655440000",
  "messageId": "7c9e6679-7425-40de-944b-e07fc1f90ae7"
}
```

#### 12.2 Continuing a Conversation

```bash
# Request
POST /chat/messages
Content-Type: application/json

{
  "content": "Now add tests for that function",
  "conversationId": "550e8400-e29b-41d4-a716-446655440000",
  "workingDirectory": "/path/to/project"
}
```

#### 12.3 Subscribing to Events

```javascript
// Subscribe to specific conversation
const eventSource = new EventSource(
  '/chat/stream?conversationId=550e8400-e29b-41d4-a716-446655440000'
);

// Task lifecycle events
eventSource.addEventListener('task_started', (e) => {
  const event = JSON.parse(e.data);
  console.log(`Agent ${event.agentName} started task ${event.taskId}`);
});

eventSource.addEventListener('task_progress', (e) => {
  const event = JSON.parse(e.data);
  console.log(`Progress: ${event.content}`);
});

// Tool events
eventSource.addEventListener('tool_call', (e) => {
  const event = JSON.parse(e.data);
  console.log(`Calling tool: ${event.data.tool}`);
});

eventSource.addEventListener('tool_result', (e) => {
  const event = JSON.parse(e.data);
  console.log(`Tool result: ${event.data.success ? 'success' : 'failed'}`);
});

// Output streaming
eventSource.addEventListener('task_output', (e) => {
  const event = JSON.parse(e.data);
  process.stdout.write(event.content);  // Stream output
});

// Completion
eventSource.addEventListener('completed', (e) => {
  const event = JSON.parse(e.data);
  console.log(`\nFinal response: ${event.content}`);
  console.log(`Message ID: ${event.messageId}`);
});

// Error handling
eventSource.addEventListener('error', (e) => {
  const event = JSON.parse(e.data);
  console.error(`Error: ${event.error}`);
});
```

#### 12.4 Cancelling a Task

```bash
DELETE /chat/tasks/your-task-id
```

#### 12.5 Retrieving History

```bash
# Get all messages in a conversation
GET /chat/conversations/550e8400-e29b-41d4-a716-446655440000/messages

# Response
{
  "success": true,
  "messages": [
    {
      "id": "7c9e6679-7425-40de-944b-e07fc1f90ae7",
      "conversationId": "550e8400-e29b-41d4-a716-446655440000",
      "role": "user",
      "content": "Hello, I need help with code",
      "createdAt": "2025-12-26T10:00:00.000Z"
    },
    {
      "id": "a1b2c3d4-5678-90ab-cdef-123456789012",
      "conversationId": "550e8400-e29b-41d4-a716-446655440000",
      "role": "assistant",
      "content": "I'd be happy to help! What would you like me to do?",
      "createdAt": "2025-12-26T10:00:05.000Z",
      "metadata": {
        "taskId": "task-uuid",
        "agentId": "agent-code",
        "usage": { "inputTokens": 150, "outputTokens": 25 },
        "duration": 2500
      }
    }
  ]
}
```

---

### 13. Best Practices

#### 13.1 Conversation Management

1. **Store conversationId** after first response for multi-turn conversations
2. **Subscribe to SSE before sending message** to not miss early events
3. **Use conversationId filter** in SSE to avoid cross-conversation noise

#### 13.2 Task Tracking

1. **taskId is in SSE events**, use it to track current execution
2. **Cancel long-running tasks** via DELETE endpoint if needed
3. **Monitor task:progress events** for execution status

#### 13.3 Error Handling

1. **Check 'error' event type** for task failures
2. **Reconnect SSE** on connection drops
3. **Validate response status** before using content

---

### 14. Limitations and Recommendations

| Limitation | Current | Recommendation |
|------------|---------|----------------|
| **Storage** | In-memory | Implement PostgreSQL/Redis for production |
| **Scaling** | Single instance | Use shared event bus (Redis Pub/Sub) |
| **Message editing** | Not supported | Add updateMessage() API |
| **Pagination** | Not implemented | Add offset/limit to getMessages() |
| **Task history** | Not persisted | Store task execution history |
| **TTL** | None | Add automatic conversation cleanup |

---

### 15. Summary

The agent-sdk2 platform uses three interconnected ID systems:

1. **ConversationId** - Groups messages, enables SSE filtering, provides context
2. **MessageId** - Tracks individual messages through the system
3. **TaskId** - Identifies agent execution units, emitted in all events

These IDs work together through the **context injection pattern** where conversationId is propagated through task context into event hooks, ensuring all SSE events can be filtered by conversation.

**Key Architecture Decisions:**
- UUIDs for all identifiers (globally unique, unpredictable)
- Server-generated messageId and taskId (consistency)
- Optional client-provided conversationId (flexibility)
- Event-based communication (real-time updates via SSE)
- Context injection pattern (clean event correlation)
